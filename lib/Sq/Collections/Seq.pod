# PODNAME: Seq
# ABSTRACT: What is Seq, and how do I use it?

__END__

=head1 NAME

Seq - A lazy sequence implementation

=head1 SYNOPSIS

A sequence is a builder/generator for iterators. You use a sequence and describe
operations on a sequence. A sequence can then be asked to return an iterator
that do the actual work.

The idea is that you never use the iterators directly. You only use a sequence.
The iterator behind it is an implementation detail.

The advantage is that you have a high-level API with map, filter, fold and so
on. It combines all the functionality you see from map, grep, List::Util, ...

But it does it lazily instead of computing everything at once. Thus it can
provide immidiat results (when possible) and/or use less memory. Sometimes even
saving computation time. It can work with infinity sequences and really large
inputs.

Everything that is an iterator can potentially used with this API. This
includes file-handles, sockets, pipes and whatever you can think of.

Once you have defined a sequence. You can execute the sequence as often you
want on whatever data you give it. From its usage it looks like an
immutable iterator.

    # always represents the range from 1 to 100.
    my $range = Seq->range(1,100);

    # prints numbers 1 to 100
    $range->iter(sub($x) { say $x });

    # prints numbers 1 to 100 again ...
    $range->iter(sub($x) { say $x });

At the moment Documentation is lacking, but the source-code is well-documented
including the test-files. Maybe you want to look at the test-files until
I have written more documentation. The API is not fully stable at the moment.

    use v5.36;
    use Seq;

    # Fibonacci Generator
    my $fib =
        Seq->concat(
            Seq->wrap(1,1),
            Seq->unfold([1,1], sub($state) {
                my $next = $state->[0] + $state->[1];
                return $next, [$state->[1],$next];
            })
        );

    # prints: 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
    $fib->take(20)->iter(sub($x) {
        say $x;
    });

    # Represents all possible combinations
    # [[clubs => 7], [clubs => 8], [clubs => 9], ...]
    my $cards =
        Seq::cartesian(
            Seq->wrap(qw/clubs spades hearts diamond/),
            Seq->wrap(qw/7 8 9 10 B D K A/)
        );

    use Path::Tiny qw(path);
    # get the maximum id from test-files so far
    my $maximum_id =
        Seq
        # get all files from 't' folder
        ->wrap( path('t')->children )
        # get basename of each file
        ->map(  sub($x) { $x->basename })
        # extract all numbers from test files. returns matches as array
        ->regex_match( qr/\A(\d+) .* \.t\z/xms, [1])
        # get the first entry of each array (there is only one)
        ->fsts
        # get the maximum number, or -1 if sequence is empty
        ->max(-1);

=head1 CONCEPT

Functions are divided into CONSTRUCTORS, METHODS, CONVERTERS.

=head2 CONSTRUCTORS

All constructor functions are directly called from the C<Seq> module. Like
C<< Seq->init( ... ) >>. The return a C<Seq>.

=head2 METHODS

All methods can be called like a method on a C<Seq> or still be called in a
functional-style. Both styles are supported. In the documentation only the
functional style how it is defined in Perl is shown.

    $seq->length();
    Seq::length($seq);

=head2 CONVERTERS

Calling style is the same as METHODS. They are called CONVERTERS because they
usually return something different than a sequence again. For example
C<< $seq->map(...) >> returns a new sequence, but C<< $seq->max >> will
return a maximum value out of a sequence that can be potentially something
different than a sequence.

=head1 IMPORTING / EXPORTING / LOADING

This module is automatically loaded when you load C<Sq>. The module is
available under C<Seq>.

=head1 CALLING STYLE

Describe functional and chaining style here.

=head1 CONSTRUCTORS

This module uses functional-programming as the main paradigm. Functions are
divided into constructors, methods and converters.

Constructor create a sequence. Methods operate on sequences and return
another new sequence. Converter transforms a sequence to some other data-type.

Methods are called methods for convenience, but no object-orientation is
involved. Perls OO capabilities are only used as a chaning mechanism.

Constructors must be called with the Package name. Functions that operate
on Sequences can either be called as a method or directly from the Package.

    my $range =
        Seq
        ->wrap(1,2,3)
        ->append(Seq->wrap(4,5,6));

or

    my $range =
        Seq::append(
            Seq->wrap(1,2,3),
            Seq->wrap(4,5,6),
        )

=head2 Seq->empty() -> $seq

Returns an empty sequence. Useful as an initial state or as a starting point.

    my $seq = Seq->empty->append( $another_seq );

=head2 Seq->range($start, $stop) -> $seq

Returns a sequence from $start to $stop. Range can also be backwards. $start
and $stop are inclusive.

    my $seq = Seq->range(1, 5); # 1,2,3,4,5
    my $seq = Seq->range(5, 1); # 5,4,3,2,1
    my $seq = Seq->range(1, 1); # 1

=head2 Seq->range_step($start, $step, $stop) -> $seq

Like C<< Seq->range >> but let's you specify a step. Both values
are inclusive and also supports steps with floating-point. Consider
floating-point inaccurassy.

    my $seq = Seq->range(1,2,10)  # [1,3,5,7,9]
    my $seq = Seq->range(10,2,1)  # [10,8,6,4,2]
    my $seq = Seq->range(1,0.2,2) # [1,1.2,1.4,1.6,1.8,2]
    my $seq = Seq->range(1,0.2,2) # [2,1.8,1.6,1.4,1.2,1]

=head2 Seq->new(...) -> $seq

Just takes whatever you pass it to, and puts it in a sequence. This should be
your primarily way to create a sequence with values.

    my $seq = Seq->new(qw/Hello World/); # "Hello", "World"
    my $seq = Seq->new(1 .. 10);         # AVOID this, use Seq->range(1, 10) instead.
    my $seq = Seq->new(@array);

=head2 Seq->wrap(...) -> $seq

Same as C<< Seq->new >>.

    my $seq = Seq->wrap(qw/Hello World/); # "Hello", "World"
    my $seq = Seq->wrap(1 .. 10);         # AVOID this, use Seq->range(1, 10) instead.
    my $seq = Seq->wrap(@array);

=head2 Seq->concat(@sequences) -> $seq

Takes multiple *Sequences* and returns a single flattened sequence.

    # 0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1, 0
    my $seq = Seq->concat(
        Seq->new(0),
        Seq->range(1, 5),
        Seq->range(5, 1),
        Seq->new(0),
    );

=head2 Seq->always($x) -> $seq

Returns an infinite sequence that always returns C<$x> as it's value.

    my $seq    = Seq->always(10);
    my $array1 = $seq->take(5)->to_array; # [10, 10, 10, 10, 10]
    my $array2 = $seq->take(3)->to_array; # [10, 10, 10]

=head2 Seq->replicate($count, $x) -> $seq

Creates a sequence representing C<$x> C<$count> times.

    # A sequence representing 100_000 times the value 1
    my $seq = Seq->replicate(100_000, 1);

=head2 Seq->unfold($state, $f) -> $seq

C<unfold> is like writing a loop to generate values. But instead that the
whole loop is completely run to an end it just runs the function C<$f>
with the current C<$state> to generate the next value in a sequence and which
next C<$state> should be used for the next call. It runs as long you try
to query data from it or the sequence indicates an end by returning C<undef>.

    my $seq = Seq->unfold(0, sub($x) {   # $x is 0 on first invocation
        return $x, $x+1;                 # return $x, and uses $x+1 as the next state.
    });

    my $first100 = $seq->take(100); # represents a sequence containing 0-99
    my $first500 = $seq->take(500); # represents a sequence containing 0-499

=head2 Seq->init($count, $f) -> $seq

Generates a maximum of C<$count> items and passes the current index to the function
C<$f> that performs the generation for that entry.

    my $seq = Seq->init(10, sub($idx) { $idx     }); # seq { 0 .. 9 }
    my $seq = Seq->init(10, sub($idx) { $idx * 2 }); # seq { 0,2,4,6,8,10,12,14,16,18 }

=head2 Seq->from_array($array) -> $seq

Generates a sequence from an array reference. This operation if very efficent
as the array is not copied. When you created an array (in a function) but want
to return it as a sequence this is the function you maybe wanna use. This way you also
can return an array as an immutable sequence, at least as long the original
array reference gets out of scope. Otherwise changing the original mutable
array will yield new/updated values.

    my $array = [1 .. 10];
    my $seq   = Seq->from_array($array);

    my $sumA = $seq->sum; # 55

    push @$array, 10;
    my $sumB = $seq->sum; # 65

=head2 Seq->from_hash($hash, $f) -> $seq

Turns a hash-ref into a sequence. When data is queried than every key,value pair
is passed to C<$f> that then can return a value that is used as the sequence
item. The hash-ref is not copied like in C<< Seq->from_array >>. This means
changing the hashref and quering the sequence again will get updated values.

    my $hash = {
        foo => 1,
        bar => 2,
        baz => 3,
    };

    my $keys   = Seq->from_hash($hash, sub($key,$value) { $key   });
    my $values = Seq->from_hash($hash, sub($key,$value) { $value });

    my $ka  = $keys->to_array; # ["foo", "bar", "baz"]
    my $sum = $values->sum;    # 6

    $hash->{maz} = 4;

    my $ka  = $keys->to_array; # ["foo", "bar", "baz", "maz"]
    my $sum = $values->sum;    # 10

=head2 Seq->from_sub($f) -> $seq

The foundation from that all sequences are created. You can turn any function
that returns a function into a sequence. The inner function must return C<undef>
to indicate the end of the sequence. As soon the inner function returns C<undef>
you can be sure that the inner function is never called again and memory should
be released.

For example an C<upto> function that just returns the value from 0 upto C<$x>
could be implemented this way.

    sub upto($x) {
        return Seq->from_sub(sub {
            # Here comes the Initial State of the iterator
            my $current = 0;

            return sub {
                if ( $current <= $x ) {
                    return $current++;
                }
                return undef;
            };
        });
    }

    # A sequence from 0-100
    my $seq = upto(100);

    # [0, 2, 4, 6, 8]
    my $first5even =
        $seq
        ->filter(sub($x) { $x % 2 == 0 })
        ->take(5)
        ->to_array;

=head2 MISSING DOC

Implemented, but not documented yet:

from_list

=head1 METHODS

Implemented, but not documented yet:

append, map, bind, flatten cartesian, join, merge, select*, choose, mapi,
filter, take, skip, indexed, distinct, distinct_by, iter, do, rev

* will maybe change

=head2 copy($seq) -> $seq

Copies a sequence, but because how sequence works it basically does nothing.
It is just here for API compatibility with other modules like Array::copy or
List::copy.

    my $same = $seq->copy;

=head1 CONVERTERS

Implemented, but not documented yet:

fold, reduce, first, last, to_array, to_list, count, sum, sum_by, min,
min_by, min_by_str, max, max_str, max_by, max_by_str, str_join, to_hash,
group_by, find


=head1 Github

Development project is on Github. L<https://github.com/DavidRaab/Seq>

=head1 AUTHOR

David Raab, C<< <davidraab83 at gmail.com> >>

=head1 LICENSE AND COPYRIGHT

This software is Copyright (c) 2023 by David Raab.

This is free software, licensed under:

  The MIT (X11) License

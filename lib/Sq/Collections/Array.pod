# PODNAME: Sq::Collections::Array
# ABSTRACT: Array functions

__END__

=pod

=encoding UTF-8

=head1 NAME

Sq::Collection::Array - Array functions

=head1 DESCRIPTION

An Sq Array is just a Perl array blessed into the Array package. You
could create it yourself by just typing.

    my $array = bless([], 'Array');

Nothing is added to the reference or nothing special besides that is done
and will never be done. This design is choosen for several reasons.

=over 4

=item Normal Array

You always can use and threat an array created by this package like a normal
Perl Array. Doing this is completely fine.

    my $array = Array->new(1,2,3,4,5);
    for my $x ( @$array ) {
        ...
    }

    push @$array, 6, 7, 8;

=item Compatibility

An Sq Array always should and can be used wherever an Array reference is
expected. This works as long a library does not do any kind of pseudo type-checking
and just uses it as an array reference.

But it also works the other way around. You always can pass a bare Perl Array to
any function that expects an array. Consider that this way you obviously cannot
use the Method syntax and are forced to use the functional-style.

    # works fine
    my $append = Array::append([1,2,3], [4,5,6]);

=item Performance

Because an Sq Array is just a normal Perl Array it doesn't have a performance
penalty. The only reason why a blessing is added is because the different
functions in this package then can be called as a method on an Array.

Most functions you find here is code you would have probably written anyway
yourself. So in some way you just can consider this package as a utility library
providing you many useful functions that you don't need to write yourself.

It makes developing in itself faster because you don't need to re-implement
different functions again and again. Also having functions for common tasks
makes code in itself shorter and better understandable leading to fewer bugs
in general.

Most functions are written in a style that tries to make the task they do as
fast as possible but still with the idea to be as correct and useful as possible.

Using functions from this package can still sometimes makes things a little bit
slower when it comes to execution timing because this library heavily depends
on passing subroutines and calling them. And calling functions are not B<free>
especially in Perl. Every function call has some overhead and sadly Perl has
no JIT or inlining capability.

But again, as a Sq Array is just a normal Perl array with an added blessing only
for the purpose for calling the function as a method, you always can use a Sq Array
like any normal Array and do whatever you want todo with it if the overhead
of this module seems to make things slower as expected.

=item Convenience

This way it just extends the possibility that you can call a lot of functions
in this package as methods on an array.

=back

=head1 CONSTRUCTORS

Constructor functions are package functions that helps in the creation of
new Arrays. All Constructor functions must be called with an arrow C<< -> >>
as you expect it from typical OO code. Like C<< Array->new(...) >> or
C<< Array->init(...) >>.

=head2 Array->new($x,$x,$x,...) : $array

Creates an Array with the specified values to C<new>. There is a special
behaviour that aborts on an C<undef>. This is to be align with the L<Sq::Collections::Seq>
data-structure that uses C<undef> to abort a sequence. But you anyway
don't want to have C<undef> as values in an array.

    my $numbers = Array->new(1,2,3,4,5);        # [1..5]
    my $numbers = Array->new(1,2,3,undef,4,5,6) # [1,2,3]

=head2 Array->wrap($x,$y,$z,...) : $array

Same as C<new>. Used this naming because of the I<Monad Abstraction>. Maybe
get deleted.

=head2 Array->empty : $array

Returns a new empty Array.

    my $empty = Array->empty;

=head2 Array->bless($array) : $array

Adds the I<Array> blessing to the array reference and returns it. Can be used
in two ways.

    my $someArray = [1,2,3];
    Array->bless($someArray);

    my $someArray = Array->bless([1,2,3]);

=head2 Array->from_array($array) : $array

Same as C<< Array->bless >>

=head2 Array->replicate($count, $value) : $array

Creates a new I<Array> that contains C<$value> C<$count> times.

    my $xs = Array->replicate(5,"x"); # [qw/x x x x x/]

=head2 Array->range($start, $stop) : $array

Generates a new array from C<$start> to C<$stop> inclusive. It also supports
counting downwards.

    my $array = Array->range(1,10); # [1..10]
    my $array = Array->range(10,1); # [10,9,8,7,6,5,4,3,2,1]

=head2 Array->range_step($start, $step, $stop) : $array

Like C<< Array->range >> but let's you specify a step. Both values
are inclusive and also supports steps with floating-point. Consider
floating-point inaccurassy.

    my $array = Array->range(1,2,10)  # [1,3,5,7,9]
    my $array = Array->range(10,2,1)  # [10,8,6,4,2]
    my $array = Array->range(1,0.2,2) # [1,1.2,1.4,1.6,1.8,2]
    my $array = Array->range(1,0.2,2) # [2,1.8,1.6,1.4,1.2,1]

=head2 Array->concat(@arrays) : $array

Returns a new array with all arrays concatenated into a new one.

    # [1,2,3,4,5,6,7,10,10,10]
    my $array = Array->concat(
        [1,2,3,4],
        Array->new(5,6,7),
        Array->replicate(3, 10),
    )

    # same as
    my $array = Array->range(1,7)->append([10,10,10]);

=head2 Array->init($count, $f_x) : $array_x

Generates a new C<Array> with C<$count> entries. An entry generating function
C<$f_x> is called by passing it the current index. The function can return multiple
values as a list and they will become one list, theoretically exceeding C<$count>.
C<undef> values are skipped.

    my $array = Array->init(5, sub($idx) { $idx });         # [0,1,2,3,4]
    my $array = Array->init(5, sub($idx) { "1" x $idx });   # ["","1","11","111","1111"]
    my $array = Array->init(3, sub($idx) { +{$idx => 1} }); # [{0 => 1},{1 => 1},{2 => 1}]
    my $array = Array->init(3, sub($idx) { 1, 1     });     # [1,1,1,1,1,1]
    my $array = Array->init(3, sub($idx) { 1, undef });     # [1,1,1]

=head2 Array->unfold($state, $f_x_state) : $array_x

Generates a new Array by passing the function C<$f_x_state> the C<$state>. C<$f_x_state>
then must return a value to be used in an array and the next state for the
next call to C<$f_x_state>. This keeps on as long C<$f_x_state> returns a defined value.

    # [1..99]
    my $array = Array->unfold(1, sub($state) {
        if ( $state < 100 ) {
            return $state, $state+1;
        }
        else {
            return;
        }
    });

The above generates an array containing the numbers from B<1> to B<99>. It works
the following.

=over

=item *

The anonymous function is called with the starting C<$state> that was set to C<1>.

=item *

The anonymous function returns C<$state> as an element to be used in the array.
In the first call this will be C<1>. The next state for the next call to the
anonymous function is set to C<$state + 1>.

=item *

The anonymous function is called with C<2> as this was the next state that
should be used.

=item *

This process keeps going on until at some point C<$state> reaches the value
C<100>. At this C<$state> the anonymous function returns nothing and the generation
of the array is aborted.

=back

C<unfold> is a very powerful function. Theoretically all constructor functions
can be implemented by C<unfold>. Everytime you use some kind of loop to generate
a new array, you can potentially replace it by an C<unfold>. This is the
functional way to generate data without relying on mutation of any variables.

    # [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]
    my $array =
        Array->concat(
            [1,1],
            Array->unfold([1,1], sub($state) {
                # $state starts with [1,1]
                my ($x,$y)   = @$state;
                my $next_fib = $x + $y;

                if ( $next_fib < 1000 ) {
                    return $next_fib, [$y,$next_fib];
                }
                return;
            })
        );

this code roughly translates to

    my $array = [1,1];
    my $state = [1,1];

    while (1) {
        my ($x,$y)   = @$state;
        my $next_fib = $x + $y;

        if ( $next_fib < 1000 ) {
            push @$array, $next_fib;
            $state = [$y,$next_fib];
            next;
        }

        last;
    }

=head1 METHODS

=head2 copy($array) : $array

Creates a shallow copy of an array, up until the first undef. This behaviour
is choosen to avoid `undef` as being as data and being consistent to all
other data-structures.

    # both are [1,2,3]
    my $copy = Array::copy([1,2,3]);
    my $copy = Array::copy([1,2,3,undef,4,5,6]);

All methods can be called as a method on an C<Array> (hence the name method),
but calling every method in a functional-style is also supported and not
discouraged. Every method listed here returns a new array as a result and
does no mutation.

As a Perl developer you should know that calling

    $array->method($x, $y);

is the same as

    Array::method($array, $x, $y);

usually calling it in the second form is discouraged because it doesn't work
properly with inheritance. But inheritance is anyway not supported by this
module and instead inheritance is highly discouraged. You do something horrible
wrong if for whatever reason you want to have inheritance.

Calling it in the functional interface form also has another benefit that it also
works with unblessed array references. This module was written from the ground
up to support both styles and also to work with any unblessed array reference.

By default you obviously cannot write.

    [1..10]->append([11..20])

because C<[1..10]> is just a perl array reference and has no blessing added
to the C<Array> module. You either must create C<[1..10]> with some constructor
methods like C<< Array->new(1..10) >> or C<< Array->range(1,10) >> or add the
blessing with C<< Array->bless >> or you just use the functional interface.

    # All arrays represent an array [1..20]
    my $array = Array::append([1..10], [11..20])
    my $array = Array->range(1,10)->append([11..20])
    my $array = Array->range(1,10)->append(Array->range(11,20))
    my $array = Array->new(1..10)->append([11..20])

But whatever you do. All methods will always return a blessed C<Array>
reference. So you always can chain methods even if you started without any.

    my $array = Array::append([1..10], [11..20])->rev # Array->range(20,1)

=head2 append($array1, $array2) : $array

returns a $new array that has $array2 appended onto $array1. C<append> only
works with two arrays (one argument in method-style). If you want to
append multiple arrays together use C<< Array->concat >> instead.

    my $array = Array->range(1,3)->append([4,5,6])->append([7,8,9]) # [1..9]

    my $array = Array->concat(
        [1..3],
        [4,5,6],
        Array->range(7,9),
    );

=head2 rev($array) : $array

returns a new array with all elements reversed

    # [5,4,3,2,1]
    my $array = Array->range(1,5)->rev

=head2 bind($array_a, $f_array_b) : $array_b

Iterates through each element of an array and passes each element to the
function C<$f_array_b>. C<$f_array_b> must then return another array.
The results of all function calls are then concatenated into a single array.

When you pass the same function C<$f_array_b> to C<map> and then C<flatten> you
achieve the same result as calling C<bind>.

    my $words = Array->new(qw/foo bar baz/);
    # [qw/f o o b a r b a z/]
    my $chars =
        $words->bind(sub($word) {
            return [split //, $word];
        });

=head2 flatten($array_of_array) : $array

Flattens an array of an array into a single array.

    # [qw/f o o b a r b a z/]
    my $chars = Array->new([qw/f o o/], [qw/b a r/], [qw/b a z/])->flatten;

    # [qw/f o o b a r b a z/]
    my $chars = Array::flatten([
        [qw/f o o/],
        [qw/b a r/],
        [qw/b a z/],
    ]);

    # [qw/f o o b a r b a z/]
    my $chars =
        Array->new(qw/foo bar baz/)
             ->map(sub($word) { [split //, $word] })
             ->flatten;

=head2 cartesian($arrayA, $arrayB) : $array_of_array_a_b

returns a new array containing the cartesian product of both arrays. The
cartesian product is every item in C<$arrayA> combined with every item in
C<$arrayB>.

    # manually creating cartesian product of two arrays
    my @cartesian;
    for my $a ( @as ) {
        for my $b ( @bs ) {
            push @cartesian, [$a, $b];
        }
    }

    # cartesian product of two arrays
    $as->cartesian($bs)->iter(sub($pair) {
        my ($a, $b) = @$pair;
        printf "A=%s B=%s\n", $a, $b;
    });

=head2 map($array_a, $f_b) : $array_b

Iterates through an array and passes each element to the function C<$f_b>. It
constructs a new array with the result of the function call. Different
to built-in C<map> it has special behaviour when C<undef> is returned. In this
case C<map> skips the element and does not add it to the resulting
array. This way C<map> behaves like a C<<->map($f)->filter($predicate)>>
in a single function call.

    # [1, 4, 9, 16, 25]
    my $squared = Array->range(1,5)->map(sub($x) { $x * $x });

    # [4, 16]
    my $squaredAndEven =
        Array->range(1,5)->map(sub($x) {
            my $square = $x * $x;
            return $square % 2 == 0 ? $square : undef
        });

    # [4, 16]
    my $squaredAndEven =
        Array
        ->range(1,5)
        ->map(   sub($x) { $x * $x     })
        ->filter(sub($x) { $x % 2 == 0 });

=head2 mapi($array_a, $f_b) : $array_b

Same as C<map> but the function C<$f> additionally gets an index passed.

    # [[0,"foo"], [1,"bar"], [2,"baz"]]
    my $array =
        Array->new(qw/foo bar baz/)
        ->mapi(sub($x,$i) { [$i,$x] };

=head2 choose($array, $f_opt) : $array

C<choose> combines C<filter> and C<map> in a single operation. Every value
of C<$array> is passed to C<$f_opt>. C<$f_opt> is supposed to return an optional
value. When it is B<Some> value than this value is added to the newly returned
array. B<None> values are skipped.

    my $data = Array->range(1,10);

    # [4,16,36,64,100]
    my $evens_squared =
        $data->choose(sub($x) {
            $x % 2 == 0 ? Some($x * $x) : None
        });

=head2 filter($array, $predicate) : $array

Iterates through each element of an array and passes it to the C<$predicate>
function. When the C<$predicate> function returns a truish value then the value
is returned in a new array. Works like the perl built-in C<grep>.

    # [2,4,6,8,10]
    my $evens =
        Array->range(1,10)
        ->filter(sub($x) { $x % 2 == 0 });

=head2 skip($array, $amount) : $array

skips C<$amount> entries of an array. Negative values or zero has no effect.
Skipping more elements than the array has leds to an empty array. Always
returns a new array, even in the case of passing it a zero or negative amount.

    # [6,7,8,9,10]
    my $array = Array->range(1,10)->skip(5);
    # [1..10]
    my $array = Array->range(1,10)->skip(-10);
    # []
    my $array = Array->range(1,10)->skip(100);

=head2 take($array, $amount) : $array

Takes the first C<$amount> elements of an array and returns it as a new array.
zero or negative elements return an empty array. Taking more elements as the
array just returns the whole array again. Always returns a new array.

    # [1,2,3,4,5]
    my $five = Array->range(1,100)->take(5);

=head2 indexed($array) : [[$index,$x], [$index,$x], ...]

Returns a new array where each element is put together with its index inside
another array. Consider using C<mapi> or C<iteri> if they are more appropiated
for whatever you wanna do.

    # [[0,1], [1,2], [2,3], [3,4], [4,5]]
    my $array = Array->range(1,5)->indexed;

=head2 zip

=head2 sort

=head2 sort_by

=head2 sort_num

=head2 sort_str

=head2 sort_hash_str

=head2 sort_hash_num

=head2 fsts

=head2 snds

=head2 to_array_of_array

=head2 distinct

=head2 distinct_by

=head2 regex_match

=head2 windowed

=head2 intersperse

=head2 repeat

=head2 take_while

=head2 skip_while

=head2 slice($array, $pos, $length) : $array

Extracts a portion of values into a new array. The values are a shallow copy,
but the array is a new array. If C<$pos> is negative than it is considered
as a position from the end. C<$length> says how much elements starting from
C<$pos> should be extracted. If C<$length> is zero or negative a new empty
array is returned. It only extracts or creates as much values the original
array can provide.

    my $data = Array->range(1,10);

    $data->slice(0,3)   # [1,2,3]
    $data->slice(1,3)   # [2,3,4]
    $data->slice(20,10) # []
    $data->slice(5,100) # [6,7,8,9,10]
    $data->slice(3,3)   # [4,5,6]
    $data->slice(9,1)   # [10]
    $data->slice(0,0)   # []
    $data->slice(0,-10) # []
    $data->slice(-3,3)  # [8,9,10]

=head1 CONVERTER

Converter are methods on an array that don't return C<Array>.

=head2 length($array) : $int

Returns the amount of elements in an array.

    my $count = Array->new(0,0,0)->length; # 3

=head2 fold($array, $state, $f_state) : $state

Iterates through each element of an array. On first iteration it passes C<$state>
and the first element of the array to the function C<$f_state>. C<$f_state> then returns
the next state that is used in the next call to C<$f_state> and the next
item of the array. This continues until all elements of an array are iterated. The
last state of the last C<$f_state> function call is returned.

When the array is empty C<$state> is immediately returned.

    # 55
    my $sum = Array->range(1,10)->fold(0, sub($state,$x) { $state + $x });

=head2 fold_mut

TODO

=head2 reduce($array, $default, $f_x) : $x

The idea is to combine two values into one value. Two values are passed to C<$f_x>
that combines the value into a new one. That new value is then passed with
the third value of an array. Continues until all values are iterated and the
last call to C<$f_x> is returned. When the array only has one value than this
value is returned without C<$f_x> is ever being called. When the array is empty
C<$default> is returned.

C<reduce> is a lot like C<fold>. C<reduce> just omits the starting state,
the idea usually is to combine something of the same type into just one value
of the same type. But through the dynamic-typing nature of Perl we usually
can exploit this behaviour and return something of any type. But still it usually
has problems when the array is empty. Here i decided that the user must pass
a C<$default> value. Typically a lot of other languages throw an exception in
that case. But this doesn't help in writing good code that doesn't crash.

Because of all of this I highly recommend to always use C<fold> instead.

    # 55
    my $sum = Array->range(1,10)->reduce(0, sub($x,$y) { $x + $y });

    # 0
    my $sum = Array->empty->reduce(0, sub($x,$y) { $x + $y });

=head2 expand($array) : ($x,$x,$x,$x,...)

Expands an array into its values. Array is just an array-reference. Calling
C<expand> is the same as writing C<@$array>.

    # all are the same
    for my $x ( $array->expand ) { ... }
    for my $x ( $array->@* )     { ... }
    for my $x ( @$array )        { ... }

=head2 first($array, $default_x) : $x

Returns the first element of an array or C<$default_x> if the array is empty.

    # 10
    my $first = Array->range(1,10)->rev->first(0);

    # 100
    my $first = Array->empty->first(100);

=head2 last($array, $default_x) : $x

Returns the last element of an array or C<$default_x> if the array is empty.

    # 1
    my $last = Array->range(1,10)->rev->last(0);

    # 100
    my $last = Array->empty->last(100);

=head2 sum($array_of_numbers) : $number

Adds all numbers together in an array. Does no type-checking or something like
that. If you have an array with other values than numbers then expect a lot of
warnings and weird results.

    # 55
    my $sum = Array->range(1,10)->sum;

=head2 sum_by($array, $f_number) : $number

A lot like C<sum> but every value of an array is first passed to the function
C<$f_number>. That function then should return a number that is used for adding. You
could achive the same by calling C<< $array->map($f_number)->sum >> but this version
is faster because it doesn't need to create an intermediate array.

    my $value = sub($hash) { $hash->{value} };
    my $data  = Array->new(
        {id => 1, value => 5 },
        {id => 2, value => 3 },
        {id => 3, value => 7 },
    );

    # 15
    my $sum = $data->sum_by($value);

    # 15
    my $sum = $data->map($value)->sum;

=head2 join($array_of_str, $sep) : $string

concatenates an array of strings into a single string. The same as the perl
built-in function C<join>.

    # "1,2,3,4,5,6,7,8,9,10"
    my $str = Array->range(1,10)->join(',');

=head2 split($array_of_str, $regex) : $array_of_array_string

performs a C<split> operation on every string in the array. This then returns
an array of arrays containing string. Every inner array is also a blessed Sq
Array.

You could achieve the same by using C<map> and then splitting every string. But
this version is faster.

    # [[1,2,3], [4,5,6]]
    my $data = Array->new("1-2-3", "4-5-6")->split(qr/-/);

    # same as
    my $data = Array->new("1-2-3", "4-5-6")->map(sub($str) {
        Array->new(split /-/, $str)
    });

=head2 group_fold

TODO

=head2 to_hash($array, $mapper) : $hash

Applies C<$mapper> function to each Array entry that return the new B<Key,Value>
to be used in a Hash. When you return a B<Key> that was already computed before
you will overwrite the previous value.

    # { 3 => "bar", 5 => "world", 1 => "a" }
    my $hash = Array->new(qw/foo bar hello world a/)->to_hash(sub($x) {
        length($x) => $x
    });

    # the above can be translated to
    my $hash = {};
    for my $x ( qw/foo bar hello world a/ ) {
        $hash->{ length $x } = $x;
    }

=head2 to_hash_of_array($array, $mapper) : $hash_of_arrays

Same as C<to_hash> but instead of overwriting previous values it collects
all values of the same key into an array.

    # { 3 => ["foo","bar"], 5 => ["hello", "world"], 1 => ["a"] }
    my $hash = Array->new(qw/foo bar hello world a/)->to_hash_of_array(sub($x) {
        length($x) => $x
    });

    # the above can be translated to
    my $hash = {};
    for my $x ( qw/foo bar hello world a/ ) {
        push $hash->{ length $x }->@*, $x;
    }

=head2 as_hash($array) : $hash

Transforms array into an hash. Same as assigning Array to a Hash. But blessed
in the C<Hash> package and as a reference.

    my %hash = @$array;
    my $hash = $array->as_hash;

=head2 keyed_by

=head2 group_by

=head2 as_hash

=head2 find

=head2 any

=head2 all

=head2 none

=head2 pick

=head1 MUTATION

The following methods mutate the array instead of creating a new one.

=head2 push($array, @values) : void

Adds elements to the end of the array. Like the built-in C<push> function
but additionally stops at first C<undef>. If you want to push C<undef>
into an array then use the perl built-in C<push @$array, undef>.

    my $array = Array->new;
    $array->push(1,2,3);    # [1,2,3]
    $array->push(4,undef,5) # [1,2,3,4]

=head2 pop($array) : $x

Removes the last element from the array and returns it. Same as perl built-in C<pop>

    my $last = $array->pop;

=head2 shift($array) : $x

Removes the first element from the array and returns it. Same as perl built-in C<shift>

    my $first = $array->shift;

=head2 unshift($array, @values) : void

Adds elements to the front of an array. Same as perl built-in C<unshift>
but stops at first C<undef>. If you still want to unshift undef to the array use
the perl built-in C<sunhift @$array, undef>.

    my $array = Array->new(1,2,3,4,5);
    $array->unshift(qw/a b c/);            # ['a','b','c',1,2,3,4,5]
    $array->unshift('d', 'e', undef, 'f'); # ['d','e','a','b','c',1,2,3,4,5]

=head2 blit($source_array, $source_index, $target_array, $target_index, $count) : void

Copies C<$count> entries from C<$source_array> at position C<$source_index> to
C<$target_array> starting at position C<$target_index>.

C<$source_index> and C<$target_index> can both be negative indexes to define
an index from the end.

Only copies as much values that are present in C<$source_array>.

    my $source = Array->range(100,105);
    my $target = Array->range(1,5);

    $source->blit(0,  $target, 0,    3); # $target -> [100,101,102,4,5]
    $source->blit(-2, $target, 0,  100); # $target -> [104,105,102,4,5]
    $source->blit(4,  $target, -3,   2); # $target -> [104,105,104,105,5]
    $source->blit(0,  $target, -1, 100); # $target -> [104,105,104,105,100,101,102,103,104,105]

=head1 SIDE-Effects

The following methods have no return value and exists for various kind
of doing side-effects.

=head2 iter($array, $f) : void

Iterates through an array and passes each element to the provided function
that does some kind of side-effect.

    # prints all numbers from 1 to 100
    Array->range(1,100)->iter(sub($x) { say $x });

=head2 iteri($array, $f) : void

Iterates through an array and passes each element inlcuding the index to the
provided function that does some kind of side-effect.

    # prints: 0 => 1, 1 => 2, 2 => 3 ...
    Array->range(1,100)->iter(sub($x,$i) { printf "%d => %d\n", $i, $x });

=head2 foreach($array, $f) : void

Same as C<iter>, just an alias.

=head2 foreachi($array, $f) : void

Same as C<iteri>, just an alias.
